1 先使用原生 webpack 来执行JS 打包

打包结果：

![image](https://ae01.alicdn.com/kf/Ubd4c7e1c66d84b89be6503e88ac8a9beT.jpg)

2 执行上步操作的目的是为了分析 打包后 js 文件的执行
  - 打包之后的文件就是一个自调用函数的使用
  - 它接收一个 modules ，而这个 modules 就是一个对象
  - 这个对象里有多个键值对组成，每个键如果不考虑路径就是我们将来需要打包的模块
  - 这些模块之所以会出现在打包之后的 built.js 中，就是因为我们自己在入口或者其它的模块中做了导入（依赖关系）
  - 在这些个要被打包的模块前面都补上了 src ，他可以用于在将来与当前工作目录配合定位到要被打包的文件
  - 这个对象的值是当前模块中的代码内容，除此之外如果遇到 require 方法，就替换成 __webpack_require__ 方法

2 将模块路径与它里面的内容组装成一个对象之后，就传给了 modules 进行使用
  - 在这里最核心的就是 __webpack_require__ 方法（ 我们都知道 webpack 可以支持所有的模块类型 ）
  - 结论就是：所有的加载模块操作都会被这个方法替代
  - 自定义的 require 第一次调用的时候接收的是 webpack.config.js 配置中的 entry 
  - 调用的过程中会将它这个键所对应的代码执行，同时还会判断当前被加载的模块里是否又导入了其它模块，如果它还导入了其它模块，那么就会递归调用，将所有的模块的都找到然后执行它里面的代码（这个逻辑当前没有分析，直接使用的结论）
  - 上述操作完成之后就已经结束了打包行为